
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>barotropy.barotropic_model &#8212; barotropy v0.4.3 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=7a515c1e"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/barotropy/barotropic_model';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">barotropy v0.4.3 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../source/introduction.html">Getting started</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../source/tutorials.html">Guided tutorials</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../source/tutorials/flashing_nozzle_fluent.html">Flashing nozzle Fluent tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../source/tutorials/centrifugal_impeller_cfx.html">Centrifugal impeller CFX tutorial</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/barotropic_model.html">Barotropic model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/developer_guide.html">Developer guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/bibliography.html">Bibliography</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../source/api/barotropy.html">API Reference</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../source/api/barotropy.barotropic_model.html">Barotropic model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../source/api/barotropy.properties.html">Fluid properties</a></li>

<li class="toctree-l2"><a class="reference internal" href="../../source/api/barotropy.math.html">Math functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../source/api/barotropy.graphics.html">Graphic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../source/api/barotropy.utilities.html">Utility functions</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../source/api/barotropy.fluent_automation.html">Fluent automation</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../source/api/barotropy.fluent_automation.fluent_automation.html">barotropy.fluent_automation.fluent_automation module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../source/api/barotropy.fluent_automation.fluent_plot_nozzle_data.html">barotropy.fluent_automation.fluent_plot_nozzle_data module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../source/api/barotropy.fluent_automation.stream_residuals.html">barotropy.fluent_automation.stream_residuals module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../source/api/barotropy.fluent_automation.stream_transcript.html">barotropy.fluent_automation.stream_transcript module</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for barotropy.barotropic_model</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mcolors</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pysolver_view</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">psv</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jaxprop</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">props</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.polynomial</span><span class="w"> </span><span class="kn">import</span> <span class="n">Polynomial</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate._ivp.ivp</span><span class="w"> </span><span class="kn">import</span> <span class="n">METHODS</span> <span class="k">as</span> <span class="n">ODE_METHODS</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">graphics</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">utilities</span> <span class="k">as</span> <span class="n">utils</span>

<span class="n">COLORS_MATLAB</span> <span class="o">=</span> <span class="n">graphics</span><span class="o">.</span><span class="n">COLORS_MATLAB</span>
<span class="n">PROCESS_TYPES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;polytropic&quot;</span><span class="p">,</span> <span class="s2">&quot;adiabatic&quot;</span><span class="p">]</span>
<span class="n">CALCULATION_TYPES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;blending&quot;</span><span class="p">,</span> <span class="s2">&quot;equilibrium&quot;</span><span class="p">,</span> <span class="s2">&quot;metastable&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="BarotropicModel">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.BarotropicModel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BarotropicModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coordinates the simulation and polynomial fitting for a barotropic process.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fluid_name : str or list of str</span>
<span class="sd">        The name(s) of the fluid(s) for the barotropic model.</span>

<span class="sd">        - Specify a single string (e.g., &#39;co2&#39;) to use the single-component model.</span>
<span class="sd">        - Specify a list of two strings (e.g., [&#39;water&#39;, &#39;nitrogen&#39;]) to use the two-component model.</span>

<span class="sd">    T_in : float</span>
<span class="sd">        Inlet temperature of the fluid in Kelvin.</span>

<span class="sd">    p_in : float</span>
<span class="sd">        Inlet pressure of the fluid in Pascals.</span>

<span class="sd">    rho_in : float</span>
<span class="sd">        Inlet density of the fluid in kilogram per cubic meter.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Applicable only to the one-component model.</span>

<span class="sd">    p_min: float</span>
<span class="sd">        Minimum pressure for the barotropic process integration in Pascals.</span>

<span class="sd">    p_max : float</span>
<span class="sd">        Maximum pressure for the barotropic process integration in Pascals.</span>

<span class="sd">    efficiency : float</span>
<span class="sd">        The efficiency of the polytropic process, dimensionless.</span>

<span class="sd">    mixture_ratio : float</span>
<span class="sd">        Mass ratio of the first to the second fluid in the mixture.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Applicable only to the two-component model.</span>

<span class="sd">    process_type : str, optional</span>
<span class="sd">        The type of polytropic process that the fluid experiences. Must be &#39;expansion&#39; or &#39;compression&#39;.</span>

<span class="sd">    calculation_type : str, optional</span>
<span class="sd">        The type of fluid property calculation for the one-component model. Options include:</span>

<span class="sd">        - ``equilibrium``: Computes equilibrium properties only.</span>
<span class="sd">        - ``metastable``: Computes metastable properties only.</span>
<span class="sd">        - ``blending``: Computes both equilibrium and metastable properties, blends them, and returns the blended properties.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Applicable only to the one-component model.</span>

<span class="sd">    blending_onset : float, optional</span>
<span class="sd">        The onset of blending in the process, typically a value between 0 and 1. Required when `calculation_type` is ``blending``.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Applicable only to the one-component model.</span>

<span class="sd">    blending_width : float, optional</span>
<span class="sd">        The width of the blending region, typically a value between 0 and 1. Required when `calculation_type` is ``blending``.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Applicable only to the one-component model.</span>

<span class="sd">    HEOS_solver : str, optional</span>
<span class="sd">        The solver algorithm used to compute the metastable states. Valid options:</span>

<span class="sd">        .. list-table::</span>
<span class="sd">            :widths: 20 50</span>
<span class="sd">            :header-rows: 1</span>

<span class="sd">            * - Solver name</span>
<span class="sd">              - Description</span>
<span class="sd">            * - ``hybr``</span>
<span class="sd">              -  Powell&#39;s hybrid trust-region algorithm</span>
<span class="sd">            * - ``lm``</span>
<span class="sd">              - Levenberg–Marquardt algorithm</span>

<span class="sd">        See `Scipy root() &lt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html&gt;`_ for more info.</span>
<span class="sd">        Recommended solvers: Both ``hybr`` and ``lm`` work well for the tested cases.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Applicable only to the one-component model.</span>

<span class="sd">    HEOS_tolerance : float, optional</span>
<span class="sd">        The tolerance for the HEOS solver.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Applicable only to the one-component model.</span>

<span class="sd">    HEOS_max_iter : int, optional</span>
<span class="sd">        The maximum number of iterations for the HEOS solver.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Applicable only to the one-component model.</span>

<span class="sd">    HEOS_print_convergence : bool, optional</span>
<span class="sd">        If True, prints convergence information for the HEOS solver.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Applicable only to the one-component model.</span>

<span class="sd">    ODE_solver : str, optional</span>
<span class="sd">        The solver to use for the ODE integration. Valid options:</span>

<span class="sd">        .. list-table::</span>
<span class="sd">            :widths: 20 50</span>
<span class="sd">            :header-rows: 1</span>

<span class="sd">            * - Solver name</span>
<span class="sd">              - Description</span>
<span class="sd">            * - ``RK23``</span>
<span class="sd">              - Explicit Runge-Kutta method of order 3(2)</span>
<span class="sd">            * - ``RK45``</span>
<span class="sd">              - Explicit Runge-Kutta method of order 5(4)</span>
<span class="sd">            * - ``DOP853``</span>
<span class="sd">              - Explicit Runge-Kutta method of order 8</span>
<span class="sd">            * - ``Radau``</span>
<span class="sd">              - Implicit Runge-Kutta method of the Radau IIA family of order 5</span>
<span class="sd">            * - ``BDF``</span>
<span class="sd">              - Implicit multi-step variable-order (1 to 5) method based on a backward differentiation formula for the derivative approximation</span>
<span class="sd">            * - ``LSODA``</span>
<span class="sd">              - Adams/BDF method with automatic stiffness detection and switching</span>

<span class="sd">        See `Scipy solver_ivp() &lt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html&gt;`_  for more info.</span>
<span class="sd">        Recommended solvers: ``BDF``, ``LSODA``, or ``Radau`` for stiff problems or ``RK45`` for non-stiff problems with smooth blending.</span>

<span class="sd">    ODE_tolerance : float, optional</span>
<span class="sd">        The relative and absolute tolerance for the ODE solver.</span>

<span class="sd">    polynomial_degree : int</span>
<span class="sd">        Degree of the polynomials to fit.</span>

<span class="sd">        .. note::</span>

<span class="sd">            When `calculation_type` is ``blending`` the degree of the polynomial in the blending region is set to 4 to achieve sufficient accuracy while preventing numerical round-off errors associated with single-precision arithmetic in CFD solvers.</span>

<span class="sd">    polynomial_format : str, optional</span>
<span class="sd">        Type of polynomial representation (``horner`` or ``standard``).</span>

<span class="sd">    polynomial_variables : list of str</span>
<span class="sd">        A list of variable names to fit polynomials to, such as &#39;density&#39;, &#39;viscosity&#39;, &#39;speed_of_sound&#39;, &#39;void_fraction&#39;, &#39;vapor_quality&#39;.</span>

<span class="sd">    output_dir : str</span>
<span class="sd">        The directory where output will be saved.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fluid_name</span><span class="p">,</span>
        <span class="n">p_in</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">T_in</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rho_in</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">p_out</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">p_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">p_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">efficiency</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.00</span><span class="p">,</span>
        <span class="n">mixture_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">process_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">backend</span><span class="o">=</span><span class="s2">&quot;HEOS&quot;</span><span class="p">,</span>
        <span class="n">calculation_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">blending_onset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">blending_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">HEOS_solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hybr&quot;</span><span class="p">,</span>
        <span class="n">HEOS_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">HEOS_max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">HEOS_print_convergence</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ODE_solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;LSODA&quot;</span><span class="p">,</span>
        <span class="n">ODE_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">polynomial_degree</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">polynomial_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;horner&quot;</span><span class="p">,</span>
        <span class="n">polynomial_variables</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;density&quot;</span><span class="p">,</span>
            <span class="s2">&quot;viscosity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;speed_of_sound&quot;</span><span class="p">,</span>
            <span class="s2">&quot;void_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vapor_quality&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">output_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;barotropic_model&quot;</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="c1"># Validate inputs and find the correct model type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_model_type</span><span class="p">(</span>
            <span class="n">fluid_name</span><span class="p">,</span>
            <span class="n">mixture_ratio</span><span class="p">,</span>
            <span class="n">calculation_type</span><span class="p">,</span>
            <span class="n">blending_onset</span><span class="p">,</span>
            <span class="n">blending_width</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Define inlet state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluid_name</span> <span class="o">=</span> <span class="n">fluid_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;one-component&quot;</span><span class="p">:</span>
            <span class="n">state_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_inlet_state</span><span class="p">(</span><span class="n">fluid_name</span><span class="p">,</span> <span class="n">p_in</span><span class="p">,</span> <span class="n">T_in</span><span class="p">,</span> <span class="n">rho_in</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span> <span class="o">=</span> <span class="n">state_in</span><span class="o">.</span><span class="n">p</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T_in</span> <span class="o">=</span> <span class="n">state_in</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rho_in</span> <span class="o">=</span> <span class="n">state_in</span><span class="o">.</span><span class="n">rho</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span> <span class="o">=</span> <span class="n">p_in</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T_in</span> <span class="o">=</span> <span class="n">T_in</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rho_in</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># not used for two-component models</span>

        <span class="c1"># Define pressure range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_pressure_range</span><span class="p">(</span>
            <span class="n">p_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_in</span><span class="p">,</span>
            <span class="n">p_out</span><span class="o">=</span><span class="n">p_out</span><span class="p">,</span>
            <span class="n">p_min</span><span class="o">=</span><span class="n">p_min</span><span class="p">,</span>
            <span class="n">p_max</span><span class="o">=</span><span class="n">p_max</span><span class="p">,</span>
            <span class="n">process_type</span><span class="o">=</span><span class="n">process_type</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Assign optional arguments with defaults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mixture_ratio</span> <span class="o">=</span> <span class="n">mixture_ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">efficiency</span> <span class="o">=</span> <span class="n">efficiency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculation_type</span> <span class="o">=</span> <span class="n">calculation_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blending_onset</span> <span class="o">=</span> <span class="n">blending_onset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blending_width</span> <span class="o">=</span> <span class="n">blending_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ODE_solver</span> <span class="o">=</span> <span class="n">ODE_solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ODE_tolerance</span> <span class="o">=</span> <span class="n">ODE_tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HEOS_solver</span> <span class="o">=</span> <span class="n">HEOS_solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HEOS_tolerance</span> <span class="o">=</span> <span class="n">HEOS_tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HEOS_max_iter</span> <span class="o">=</span> <span class="n">HEOS_max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">HEOS_print_convergence</span> <span class="o">=</span> <span class="n">HEOS_print_convergence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polynomial_degree</span> <span class="o">=</span> <span class="n">polynomial_degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polynomial_format</span> <span class="o">=</span> <span class="n">polynomial_format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polynomial_variables</span> <span class="o">=</span> <span class="n">polynomial_variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>

        <span class="c1"># Initialize variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ode_solution</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_model_type</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fluid_name</span><span class="p">,</span>
        <span class="n">mixture_ratio</span><span class="p">,</span>
        <span class="n">calculation_type</span><span class="p">,</span>
        <span class="n">blending_onset</span><span class="p">,</span>
        <span class="n">blending_width</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Validate inputs for one-component and two-component models</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fluid_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># One-component model</span>
            <span class="k">if</span> <span class="n">calculation_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">CALCULATION_TYPES</span><span class="p">:</span>
                <span class="n">allowed_types</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">ptype</span> <span class="ow">in</span> <span class="n">CALCULATION_TYPES</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid parameter calculation_type=</span><span class="si">{</span><span class="n">calculation_type</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;It must be one of </span><span class="si">{</span><span class="n">allowed_types</span><span class="si">}</span><span class="s2"> for the one-component model.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mixture_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Parameter mixture_ratio=</span><span class="si">{</span><span class="n">mixture_ratio</span><span class="si">}</span><span class="s2"> must be None for the one-component model.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;one-component&quot;</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">fluid_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fluid_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fluid_name</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Two-component model</span>
            <span class="k">if</span> <span class="n">mixture_ratio</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mixture_ratio</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Parameter mixture_ratio=</span><span class="si">{</span><span class="n">mixture_ratio</span><span class="si">}</span><span class="s2"> must be a positive scalar for the two-component model.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">calculation_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="n">blending_onset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="n">blending_width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;The following parameters must be None for the two-component model:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  - calculation_type: </span><span class="si">{</span><span class="n">calculation_type</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  - blending_onset: </span><span class="si">{</span><span class="n">blending_onset</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  - blending_width: </span><span class="si">{</span><span class="n">blending_width</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;two-component&quot;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Input parameter &#39;fluid_name&#39;=</span><span class="si">{</span><span class="n">fluid_name</span><span class="si">}</span><span class="s2"> must be either:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  1. A single string for the one-component barotropic model</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  2. A list of two strings for the two-component barotropic model.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_inlet_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fluid_name</span><span class="p">,</span> <span class="n">p_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T_in</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rho_in</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resolves the inlet thermodynamic state from any valid combination of (p_in, T_in, rho_in).</span>

<span class="sd">        Returns:</span>
<span class="sd">            state_in</span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError if input combination is invalid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fluid</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">Fluid</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">fluid_name</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">)</span>
        <span class="n">num_given</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">p_in</span><span class="p">,</span> <span class="n">T_in</span><span class="p">,</span> <span class="n">rho_in</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">num_given</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least two of (p_in, T_in, rho_in) must be provided.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_given</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Only two of (p_in, T_in, rho_in) should be provided. The third will be calculated.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Determine which input pair was provided and compute the missing property</span>
        <span class="k">if</span> <span class="n">p_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">T_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span><span class="n">props</span><span class="o">.</span><span class="n">PT_INPUTS</span><span class="p">,</span> <span class="n">p_in</span><span class="p">,</span> <span class="n">T_in</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">p_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rho_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span><span class="n">props</span><span class="o">.</span><span class="n">DmassP_INPUTS</span><span class="p">,</span> <span class="n">rho_in</span><span class="p">,</span> <span class="n">p_in</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">T_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rho_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span><span class="n">props</span><span class="o">.</span><span class="n">DmassT_INPUTS</span><span class="p">,</span> <span class="n">rho_in</span><span class="p">,</span> <span class="n">T_in</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected error during state resolution.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_pressure_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">,</span> <span class="n">p_min</span><span class="p">,</span> <span class="n">p_max</span><span class="p">,</span> <span class="n">process_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resolve p_min, p_max, and process_type from user input.</span>

<span class="sd">        Args:</span>
<span class="sd">            p_in (float): Inlet pressure [Pa]</span>
<span class="sd">            p_out (float or None): Outlet pressure [Pa]</span>
<span class="sd">            p_min (float or None): Minimum pressure [Pa]</span>
<span class="sd">            p_max (float or None): Maximum pressure [Pa]</span>
<span class="sd">            process_type (str or None): &quot;expansion&quot; or &quot;compression&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple (p_min, p_max, process_type)</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If input combinations are invalid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Case 1: process_type is explicitly given → p_min and p_max are mandatory</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-6</span>
        <span class="k">if</span> <span class="n">process_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">process_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;expansion&quot;</span><span class="p">,</span> <span class="s2">&quot;compression&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid process_type=&#39;</span><span class="si">{</span><span class="n">process_type</span><span class="si">}</span><span class="s2">&#39;. Must be &#39;expansion&#39; or &#39;compression&#39;.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">p_min</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">p_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;When process_type is specified, both p_min and p_max must be provided. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Got p_min=</span><span class="si">{</span><span class="n">p_min</span><span class="si">}</span><span class="s2">, p_max=</span><span class="si">{</span><span class="n">p_max</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            
            <span class="k">if</span> <span class="n">p_in</span><span class="o">/</span><span class="n">p_min</span> <span class="o">&lt;</span>  <span class="mi">1</span> <span class="o">-</span> <span class="n">eps</span> <span class="ow">or</span> <span class="n">p_in</span><span class="o">/</span><span class="n">p_max</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">eps</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Inlet pressure p_in=</span><span class="si">{</span><span class="n">p_in</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2"> must lie within p_min=</span><span class="si">{</span><span class="n">p_min</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2"> and p_max=</span><span class="si">{</span><span class="n">p_max</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">p_min</span><span class="p">,</span> <span class="n">p_max</span><span class="p">,</span> <span class="n">process_type</span>

        <span class="c1"># Case 2: Infer everything from p_in and p_out</span>
        <span class="k">if</span> <span class="n">p_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If process_type is not specified, both p_in and p_out must be provided.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">p_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">p_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;When using p_in and p_out to infer the process type, both p_min and p_max must be None.&quot;</span>
            <span class="p">)</span>

        <span class="n">process_type</span> <span class="o">=</span> <span class="s2">&quot;expansion&quot;</span> <span class="k">if</span> <span class="n">p_out</span> <span class="o">&lt;</span> <span class="n">p_in</span> <span class="k">else</span> <span class="s2">&quot;compression&quot;</span>
        <span class="n">p_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">)</span>
        <span class="n">p_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">p_min</span><span class="p">,</span> <span class="n">p_max</span><span class="p">,</span> <span class="n">process_type</span>

<div class="viewcode-block" id="BarotropicModel.solve">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.BarotropicModel.solve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the equations for the one-component or two-component barotropic model and stores the fluid properties.</span>
<span class="sd">        The type of calculation performed is selected automatically depending on the number of fluid names defined when initializing the class.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        barotropic_model_one_component :</span>
<span class="sd">            Calculation of fluid properties for the one-component model.</span>
<span class="sd">        barotropic_model_two_component :</span>
<span class="sd">            Calculation of fluid properties for the two-component model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Manually pass all parameters to the ODE solver function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;one-component&quot;</span><span class="p">:</span>

            <span class="c1"># Integrate upward from p_in to p_max:</span>
            <span class="n">states_up</span><span class="p">,</span> <span class="n">ode_solution_up</span> <span class="o">=</span> <span class="n">barotropic_model_one_component</span><span class="p">(</span>
                <span class="n">fluid_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fluid_name</span><span class="p">,</span>
                <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">,</span>
                <span class="n">p_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_in</span><span class="p">,</span>
                <span class="n">rho_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho_in</span><span class="p">,</span>
                <span class="n">p_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_max</span><span class="p">,</span>
                <span class="n">efficiency</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efficiency</span><span class="p">,</span>
                <span class="n">process_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">process_type</span><span class="p">,</span>
                <span class="n">calculation_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calculation_type</span><span class="p">,</span>
                <span class="n">blending_onset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">blending_onset</span><span class="p">,</span>
                <span class="n">blending_width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">blending_width</span><span class="p">,</span>
                <span class="n">ODE_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ODE_solver</span><span class="p">,</span>
                <span class="n">ODE_tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ODE_tolerance</span><span class="p">,</span>
                <span class="n">HEOS_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">HEOS_solver</span><span class="p">,</span>
                <span class="n">HEOS_tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">HEOS_tolerance</span><span class="p">,</span>
                <span class="n">HEOS_max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">HEOS_max_iter</span><span class="p">,</span>
                <span class="n">HEOS_print_convergence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">HEOS_print_convergence</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Integrate downward from p_in to p_min:</span>
            <span class="n">states_down</span><span class="p">,</span> <span class="n">ode_solution_down</span> <span class="o">=</span> <span class="n">barotropic_model_one_component</span><span class="p">(</span>
                <span class="n">fluid_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fluid_name</span><span class="p">,</span>
                <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">,</span>
                <span class="n">p_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_in</span><span class="p">,</span>
                <span class="n">rho_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rho_in</span><span class="p">,</span>
                <span class="n">p_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_min</span><span class="p">,</span>
                <span class="n">efficiency</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efficiency</span><span class="p">,</span>
                <span class="n">process_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">process_type</span><span class="p">,</span>
                <span class="n">calculation_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calculation_type</span><span class="p">,</span>
                <span class="n">blending_onset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">blending_onset</span><span class="p">,</span>
                <span class="n">blending_width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">blending_width</span><span class="p">,</span>
                <span class="n">ODE_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ODE_solver</span><span class="p">,</span>
                <span class="n">ODE_tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ODE_tolerance</span><span class="p">,</span>
                <span class="n">HEOS_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">HEOS_solver</span><span class="p">,</span>
                <span class="n">HEOS_tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">HEOS_tolerance</span><span class="p">,</span>
                <span class="n">HEOS_max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">HEOS_max_iter</span><span class="p">,</span>
                <span class="n">HEOS_print_convergence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">HEOS_print_convergence</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Store solution</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_in</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">states_up</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">states_up</span><span class="p">[</span><span class="n">key</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">states_down</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mf">0.</span><span class="p">))))</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">states_up</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ode_solution</span> <span class="o">=</span> <span class="p">(</span><span class="n">ode_solution_up</span><span class="p">,</span> <span class="n">ode_solution_down</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;two-component&quot;</span><span class="p">:</span>
            <span class="n">states_up</span><span class="p">,</span> <span class="n">ode_solution_up</span> <span class="o">=</span> <span class="n">barotropic_model_two_component</span><span class="p">(</span>
                <span class="n">fluid_name_1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fluid_name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">fluid_name_2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fluid_name</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">mixture_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mixture_ratio</span><span class="p">,</span>
                <span class="n">T_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T_in</span><span class="p">,</span>
                <span class="n">p_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_in</span><span class="p">,</span>
                <span class="n">p_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_max</span><span class="p">,</span>
                <span class="n">efficiency</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efficiency</span><span class="p">,</span>
                <span class="n">process_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">process_type</span><span class="p">,</span>
                <span class="n">ODE_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ODE_solver</span><span class="p">,</span>
                <span class="n">ODE_tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ODE_tolerance</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">states_down</span><span class="p">,</span> <span class="n">ode_solution_down</span> <span class="o">=</span> <span class="n">barotropic_model_two_component</span><span class="p">(</span>
                <span class="n">fluid_name_1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fluid_name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">fluid_name_2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fluid_name</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">mixture_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mixture_ratio</span><span class="p">,</span>
                <span class="n">T_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T_in</span><span class="p">,</span>
                <span class="n">p_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_in</span><span class="p">,</span>
                <span class="n">p_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_min</span><span class="p">,</span>
                <span class="n">efficiency</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">efficiency</span><span class="p">,</span>
                <span class="n">process_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">process_type</span><span class="p">,</span>
                <span class="n">ODE_solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ODE_solver</span><span class="p">,</span>
                <span class="n">ODE_tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ODE_tolerance</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Store solution</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_in</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">states_up</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">states_up</span><span class="p">[</span><span class="n">key</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">states_down</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">states_up</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ode_solution</span> <span class="o">=</span> <span class="p">(</span><span class="n">ode_solution_up</span><span class="p">,</span> <span class="n">ode_solution_down</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Invalid value for model_type=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model_type</span><span class="si">}</span><span class="s2">. Something went wrong during input validation.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<div class="viewcode-block" id="BarotropicModel.fit_polynomials">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.BarotropicModel.fit_polynomials">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_polynomials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits polynomials to the states using the PolynomialFitter class.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        PolynomialFitter :</span>
<span class="sd">            Class used for generating fitting polynomials.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ode_solution</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
            <span class="c1"># msg = &quot;Fluid properties are not computed. Please call the &#39;solve()&#39; method first.&quot;</span>
            <span class="c1"># raise ValueError(msg)</span>

        <span class="c1"># Fit the polynomials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span> <span class="o">=</span> <span class="n">PolynomialFitter</span><span class="p">(</span>
            <span class="n">states</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">,</span>
            <span class="n">state_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state_in</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polynomial_variables</span><span class="p">,</span>
            <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polynomial_degree</span><span class="p">,</span>
            <span class="n">model_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model_type</span><span class="p">,</span>
            <span class="n">calculation_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calculation_type</span><span class="p">,</span>
            <span class="n">output_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span><span class="o">.</span><span class="n">fit_polynomials</span><span class="p">()</span>

        <span class="c1"># Automatically initialize the ExpressionExporter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exporter</span> <span class="o">=</span> <span class="n">ExpressionExporter</span><span class="p">(</span>
            <span class="n">poly_fitter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span><span class="p">,</span>
            <span class="n">poly_format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">polynomial_format</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BarotropicModel.export_expressions_fluent">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.BarotropicModel.export_expressions_fluent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">export_expressions_fluent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exports the polynomial expressions in a format suitable for Ansys Fluent.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_dir : str, optional</span>
<span class="sd">            The directory where the expressions will be saved. It uses a default directory if not provided.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ExpressionExporter :</span>
<span class="sd">            Class for exporting polynomial expressions for use in CFD software.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">exporter</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;ExpressionExporter not initialized. Please call the method &#39;fit_polynomials()&#39; first.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exporter</span><span class="o">.</span><span class="n">export_expressions_fluent</span><span class="p">(</span><span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="BarotropicModel.export_expressions_cfx">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.BarotropicModel.export_expressions_cfx">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">export_expressions_cfx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exports the polynomial expressions in a format suitable for Ansys CFX.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_dir : str, optional</span>
<span class="sd">            The directory where the expressions will be saved. It uses a default directory if not provided.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ExpressionExporter :</span>
<span class="sd">            Class for exporting polynomial expressions for use in CFD software.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">exporter</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;ExpressionExporter not initialized. Please call the method &#39;fit_polynomials()&#39; first.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exporter</span><span class="o">.</span><span class="n">export_expressions_cfx</span><span class="p">(</span><span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="barotropic_model_one_component">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.barotropic_model_one_component">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">barotropic_model_one_component</span><span class="p">(</span>
    <span class="n">fluid_name</span><span class="p">,</span>
    <span class="n">p_in</span><span class="p">,</span>
    <span class="n">rho_in</span><span class="p">,</span>
    <span class="n">p_out</span><span class="p">,</span>
    <span class="n">efficiency</span><span class="p">,</span>
    <span class="n">backend</span><span class="o">=</span><span class="s2">&quot;HEOS&quot;</span><span class="p">,</span>
    <span class="n">process_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">calculation_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">blending_onset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">blending_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">HEOS_solver</span><span class="o">=</span><span class="s2">&quot;hybr&quot;</span><span class="p">,</span>
    <span class="n">HEOS_tolerance</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">HEOS_max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">HEOS_print_convergence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">ODE_solver</span><span class="o">=</span><span class="s2">&quot;lsoda&quot;</span><span class="p">,</span>
    <span class="n">ODE_tolerance</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates a polytropic process for a given fluid from an inlet state to a specified outlet pressure.</span>

<span class="sd">    This function integrates the differential equation describing the polytropic process, which may involve phase changes, using the relationship:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \frac{\text{d}h}{\text{d}p} = \frac{\eta_p}{\rho}</span>

<span class="sd">    where :math:`h` is the specific enthalpy, :math:`p` is the pressure, :math:`\eta_p` is the process efficiency, and :math:`\rho` is the density of the fluid.</span>

<span class="sd">    The evaluation of fluid properties varies based on the ``calculation_type`` parameter:</span>

<span class="sd">    - ``calculation_type=&#39;equilibrium&#39;``: Computes properties assuming thermodynamic equilibrium using the CoolProp property solver.</span>
<span class="sd">    - ``calculation_type=&#39;metastable&#39;``: Computes properties based on the Helmholtz energy equations of state, iterating on density and temperature.</span>
<span class="sd">    - ``calculation_type=&#39;blending&#39;``: Blends equilibrium and metastable properties according to the fluid vapor quality.</span>

<span class="sd">    In single-phase regions, all calculation types yield identical results. The differences arise in the evaluation within the two-phase region, where the handling of equilibrium and metastable fluid properties differs.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The choice of ODE solver can significantly impact the accuracy and stability of the simulation. The ``BDF`` and ``LSODA`` solvers are recommended for general use, particularly for stiff problems involving equilibrium phase change or narrow blending widths, while `RK45` may be suitable for non-stiff problems with no phase change or smooth phase transitions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fluid_name : str</span>
<span class="sd">        The name of the fluid to be used in the simulation (e.g., &#39;Water&#39;).</span>

<span class="sd">    p_in : float</span>
<span class="sd">        Inlet pressure of the fluid in Pascal.</span>

<span class="sd">    rho_in : float</span>
<span class="sd">        Inlet density of the fluid in kilogram per cubic meter.</span>

<span class="sd">    p_out : float</span>
<span class="sd">        Outlet pressure of the fluid in Pascals.</span>

<span class="sd">    efficiency : float</span>
<span class="sd">        The efficiency of the polytropic process, dimensionless.</span>

<span class="sd">    calculation_type : str</span>
<span class="sd">        The type of calculation to perform. Options include:</span>

<span class="sd">        - ``equilibrium``: Computes equilibrium properties only.</span>
<span class="sd">        - ``metastable``: Computes metastable properties only.</span>
<span class="sd">        - ``blending``: Computes both equilibrium and metastable properties, blends them, and returns the blended properties.</span>

<span class="sd">    blending_onset : float, optional</span>
<span class="sd">        The onset of blending in the process, typically a value between 0 and 1. Required when `calculation_type` is ``blending``.</span>
<span class="sd">    blending_width : float, optional</span>
<span class="sd">        The width of the blending region, typically a value between 0 and 1. Required when `calculation_type` is ``blending``.</span>

<span class="sd">    HEOS_solver : str, optional</span>
<span class="sd">        The solver algorithm used to compute the metastable states. Valid options:</span>

<span class="sd">        .. list-table::</span>
<span class="sd">            :widths: 20 50</span>
<span class="sd">            :header-rows: 1</span>

<span class="sd">            * - Solver name</span>
<span class="sd">              - Description</span>
<span class="sd">            * - ``hybr``</span>
<span class="sd">              -  Powell&#39;s hybrid trust-region algorithm</span>
<span class="sd">            * - ``lm``</span>
<span class="sd">              - Levenberg-Marquardt algorithm</span>

<span class="sd">        See `Scipy root() &lt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html&gt;`_ for more info.</span>
<span class="sd">        Recommended solvers: Both ``hybr`` and ``lm`` work well for the tested cases.</span>

<span class="sd">    HEOS_tolerance : float, optional</span>
<span class="sd">        The tolerance for the HEOS solver.</span>

<span class="sd">    HEOS_max_iter : int, optional</span>
<span class="sd">        The maximum number of iterations for the HEOS solver.</span>

<span class="sd">    HEOS_print_convergence : bool, optional</span>
<span class="sd">        If True, prints convergence information for the HEOS solver.</span>

<span class="sd">    ODE_solver : str, optional</span>
<span class="sd">        The solver to use for the ODE integration. Valid options:</span>

<span class="sd">        .. list-table::</span>
<span class="sd">            :widths: 20 50</span>
<span class="sd">            :header-rows: 1</span>

<span class="sd">            * - Solver name</span>
<span class="sd">              - Description</span>
<span class="sd">            * - ``RK23``</span>
<span class="sd">              - Explicit Runge-Kutta method of order 3(2)</span>
<span class="sd">            * - ``RK45``</span>
<span class="sd">              - Explicit Runge-Kutta method of order 5(4)</span>
<span class="sd">            * - ``DOP853``</span>
<span class="sd">              - Explicit Runge-Kutta method of order 8</span>
<span class="sd">            * - ``Radau``</span>
<span class="sd">              - Implicit Runge-Kutta method of the Radau IIA family of order 5</span>
<span class="sd">            * - ``BDF``</span>
<span class="sd">              - Implicit multi-step variable-order (1 to 5) method based on a backward differentiation formula for the derivative approximation</span>
<span class="sd">            * - ``LSODA``</span>
<span class="sd">              - Adams/BDF method with automatic stiffness detection and switching</span>

<span class="sd">        See `Scipy solver_ivp() &lt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html&gt;`_  for more info.</span>
<span class="sd">        Recommended solvers: ``BDF``, ``LSODA``, or ``Radau`` for stiff problems or ``RK45`` for non-stiff problems with smooth blending.</span>

<span class="sd">    ODE_tolerance : float, optional</span>
<span class="sd">        The relative and absolute tolerance for the ODE solver.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    states : dictionary of arrays</span>
<span class="sd">        A dictionary of Numpy arrays representing the properties of the fluid at each evaluation point.</span>
<span class="sd">    solution : scipy.integrate.OdeResult</span>
<span class="sd">        The result of the ODE integration containing information about the solver process.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check if the provided HEOS solver is valid</span>
    <span class="n">valid_solvers_heos</span> <span class="o">=</span> <span class="n">psv</span><span class="o">.</span><span class="n">nonlinear_system</span><span class="o">.</span><span class="n">SOLVER_OPTIONS</span>
    <span class="k">if</span> <span class="n">HEOS_solver</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_solvers_heos</span><span class="p">:</span>
        <span class="n">error_message</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid HEOS solver &#39;</span><span class="si">{</span><span class="n">HEOS_solver</span><span class="si">}</span><span class="s2">&#39; provided. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Valid solvers are: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">valid_solvers_heos</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>

    <span class="c1"># Check if the provided ODE solver is valid</span>
    <span class="n">valid_solvers_ode</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ODE_METHODS</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">ODE_solver</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_solvers_ode</span><span class="p">:</span>
        <span class="n">error_message</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid ODE solver &#39;</span><span class="si">{</span><span class="n">ODE_solver</span><span class="si">}</span><span class="s2">&#39; provided. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Valid solver are: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">valid_solvers_ode</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="s2">&quot;Recommended solvers: &#39;BDF&#39;, &#39;LSODA&#39; or &#39;Radau&#39; stiff problems involving equilibrium property calculations or blending calculations with a narrow blending width. &#39;RK45&#39; can be used for non-stiff problems with a wide blending width.&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>

    <span class="c1"># Pre-process efficiency value</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">efficiency</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Efficiency must be between 0 and 1. Provided: </span><span class="si">{</span><span class="n">efficiency</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">process_type</span> <span class="o">==</span> <span class="s2">&quot;compression&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">efficiency</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Efficiency cannot be zero for compression (division by zero).&quot;</span>
            <span class="p">)</span>
        <span class="n">efficiency</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">efficiency</span>
    <span class="k">elif</span> <span class="n">process_type</span> <span class="o">!=</span> <span class="s2">&quot;expansion&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid process_type=&#39;</span><span class="si">{</span><span class="n">process_type</span><span class="si">}</span><span class="s2">&#39;. Must be &#39;expansion&#39; or &#39;compression&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Initialize fluid and compute inlet state</span>
    <span class="n">fluid</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">Fluid</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">fluid_name</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">state_in</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span>
        <span class="n">props</span><span class="o">.</span><span class="n">DmassP_INPUTS</span><span class="p">,</span> <span class="n">rho_in</span><span class="p">,</span> <span class="n">p_in</span><span class="p">,</span> <span class="n">supersaturation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">generalize_quality</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Determine the type of phase change process</span>
    <span class="n">phase_change_type</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;flashing&quot;</span> <span class="k">if</span> <span class="n">state_in</span><span class="o">.</span><span class="n">s</span> <span class="o">&lt;</span> <span class="n">fluid</span><span class="o">.</span><span class="n">critical_point</span><span class="o">.</span><span class="n">s</span> <span class="k">else</span> <span class="s2">&quot;condensation&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Initial guess for the metastable state (is updated at each iteration)</span>
    <span class="n">rhoT_guess_metastable</span> <span class="o">=</span> <span class="p">[</span><span class="n">state_in</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">state_in</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

    <span class="c1"># Differential equation defining the polytropic process</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">odefun</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">rhoT_guess_metastable</span>  <span class="c1"># Allows modification within the function scope</span>

        <span class="c1"># Rename arguments</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">t</span>
        <span class="p">(</span><span class="n">h</span><span class="p">,)</span> <span class="o">=</span> <span class="n">y</span>

        <span class="c1"># Do calculations according to specified type</span>
        <span class="k">if</span> <span class="n">calculation_type</span> <span class="o">==</span> <span class="s2">&quot;equilibrium&quot;</span><span class="p">:</span>

            <span class="c1"># Compute equilibrium thermodynamic state</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># Compute equilibrium state using CoolProp solver</span>
                <span class="n">state_eq</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span>
                    <span class="n">input_type</span><span class="o">=</span><span class="n">props</span><span class="o">.</span><span class="n">HmassP_INPUTS</span><span class="p">,</span>
                    <span class="n">prop_1</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                    <span class="n">prop_2</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                    <span class="n">generalize_quality</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">supersaturation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">except</span><span class="p">:</span>  <span class="c1"># Switch custom solver if something goes wrong</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: CoolProp solver failed, switching to custom solver...&quot;</span><span class="p">)</span>
                <span class="n">state_eq</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">get_state_equilibrium</span><span class="p">(</span>
                    <span class="n">prop_1</span><span class="o">=</span><span class="s2">&quot;enthalpy&quot;</span><span class="p">,</span>
                    <span class="n">prop_1_value</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                    <span class="n">prop_2</span><span class="o">=</span><span class="s2">&quot;pressure&quot;</span><span class="p">,</span>
                    <span class="n">prop_2_value</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                    <span class="n">rhoT_guess</span><span class="o">=</span><span class="n">rhoT_guess_metastable</span><span class="p">,</span>
                    <span class="n">generalize_quality</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">supersaturation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">solver_algorithm</span><span class="o">=</span><span class="n">HEOS_solver</span><span class="p">,</span>
                    <span class="n">solver_tolerance</span><span class="o">=</span><span class="n">HEOS_tolerance</span><span class="p">,</span>
                    <span class="n">solver_max_iterations</span><span class="o">=</span><span class="n">HEOS_max_iter</span><span class="p">,</span>
                    <span class="n">print_convergence</span><span class="o">=</span><span class="n">HEOS_print_convergence</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Update guess for the next integration step</span>
            <span class="n">rhoT_guess_metastable</span> <span class="o">=</span> <span class="p">[</span><span class="n">state_eq</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">state_eq</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
            <span class="n">dhdp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">efficiency</span> <span class="o">/</span> <span class="n">state_eq</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">dhdp</span><span class="p">,</span> <span class="n">state_eq</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">calculation_type</span> <span class="o">==</span> <span class="s2">&quot;metastable&quot;</span><span class="p">:</span>
            <span class="c1"># Compute metastable state using custom solver</span>
            <span class="n">state_meta</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">get_state_metastable</span><span class="p">(</span>
                <span class="n">prop_1</span><span class="o">=</span><span class="s2">&quot;enthalpy&quot;</span><span class="p">,</span>
                <span class="n">prop_1_value</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                <span class="n">prop_2</span><span class="o">=</span><span class="s2">&quot;pressure&quot;</span><span class="p">,</span>
                <span class="n">prop_2_value</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                <span class="n">rhoT_guess</span><span class="o">=</span><span class="n">rhoT_guess_metastable</span><span class="p">,</span>
                <span class="n">generalize_quality</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">supersaturation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">solver_algorithm</span><span class="o">=</span><span class="n">HEOS_solver</span><span class="p">,</span>
                <span class="n">solver_tolerance</span><span class="o">=</span><span class="n">HEOS_tolerance</span><span class="p">,</span>
                <span class="n">solver_max_iterations</span><span class="o">=</span><span class="n">HEOS_max_iter</span><span class="p">,</span>
                <span class="n">print_convergence</span><span class="o">=</span><span class="n">HEOS_print_convergence</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Update guess for the next integration step</span>
            <span class="n">rhoT_guess_metastable</span> <span class="o">=</span> <span class="p">[</span><span class="n">state_meta</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">state_meta</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
            <span class="n">dhdp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">efficiency</span> <span class="o">/</span> <span class="n">state_meta</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">dhdp</span><span class="p">,</span> <span class="n">state_meta</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">calculation_type</span> <span class="o">==</span> <span class="s2">&quot;blending&quot;</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">blending_onset</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">blending_width</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The variables blending_onset=</span><span class="si">{</span><span class="n">blending_onset</span><span class="si">}</span><span class="s2"> and blending_width=</span><span class="si">{</span><span class="n">blending_width</span><span class="si">}</span><span class="s2"> must be floats when calculation_type=&#39;blending&#39;.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># Compute equilibrium thermodynamic state</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># Compute equilibrium state using CoolProp solver</span>
                <span class="n">state_eq</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span>
                    <span class="n">input_type</span><span class="o">=</span><span class="n">props</span><span class="o">.</span><span class="n">HmassP_INPUTS</span><span class="p">,</span>
                    <span class="n">prop_1</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                    <span class="n">prop_2</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                    <span class="n">generalize_quality</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">supersaturation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">except</span><span class="p">:</span>  <span class="c1"># Switch custom solver if something goes wrong</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: CoolProp solver failed, switching to custom solver...&quot;</span><span class="p">)</span>
                <span class="n">state_eq</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">get_state_equilibrium</span><span class="p">(</span>
                    <span class="n">prop_1</span><span class="o">=</span><span class="s2">&quot;enthalpy&quot;</span><span class="p">,</span>
                    <span class="n">prop_1_value</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                    <span class="n">prop_2</span><span class="o">=</span><span class="s2">&quot;pressure&quot;</span><span class="p">,</span>
                    <span class="n">prop_2_value</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                    <span class="n">rhoT_guess</span><span class="o">=</span><span class="n">rhoT_guess_metastable</span><span class="p">,</span>
                    <span class="n">generalize_quality</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">supersaturation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">solver_algorithm</span><span class="o">=</span><span class="n">HEOS_solver</span><span class="p">,</span>
                    <span class="n">solver_tolerance</span><span class="o">=</span><span class="n">HEOS_tolerance</span><span class="p">,</span>
                    <span class="n">solver_max_iterations</span><span class="o">=</span><span class="n">HEOS_max_iter</span><span class="p">,</span>
                    <span class="n">print_convergence</span><span class="o">=</span><span class="n">HEOS_print_convergence</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Determine if metastable state should be used (avoid metastable computations too deep into the 2-phase region)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">state_eq</span><span class="p">[</span><span class="s2">&quot;vapor_quality&quot;</span><span class="p">]</span>
            <span class="n">use_metastable</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">phase_change_type</span> <span class="o">==</span> <span class="s2">&quot;flashing&quot;</span>
                <span class="ow">and</span> <span class="n">q</span> <span class="o">&lt;=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">blending_onset</span> <span class="o">+</span> <span class="n">blending_width</span><span class="p">)</span>
            <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">phase_change_type</span> <span class="o">==</span> <span class="s2">&quot;condensation&quot;</span>
                <span class="ow">and</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">blending_onset</span> <span class="o">-</span> <span class="n">blending_width</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Compute metastable state or use equilibrium state</span>
            <span class="c1"># Do the calculation only within the blending region to avoid using the HEOS solver too deep into the two-phase region</span>
            <span class="k">if</span> <span class="n">use_metastable</span><span class="p">:</span>
                <span class="n">state_meta</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">get_state_metastable</span><span class="p">(</span>
                    <span class="n">prop_1</span><span class="o">=</span><span class="s2">&quot;enthalpy&quot;</span><span class="p">,</span>
                    <span class="n">prop_1_value</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                    <span class="n">prop_2</span><span class="o">=</span><span class="s2">&quot;pressure&quot;</span><span class="p">,</span>
                    <span class="n">prop_2_value</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                    <span class="n">rhoT_guess</span><span class="o">=</span><span class="n">rhoT_guess_metastable</span><span class="p">,</span>
                    <span class="n">generalize_quality</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">supersaturation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">solver_algorithm</span><span class="o">=</span><span class="n">HEOS_solver</span><span class="p">,</span>
                    <span class="n">solver_tolerance</span><span class="o">=</span><span class="n">HEOS_tolerance</span><span class="p">,</span>
                    <span class="n">solver_max_iterations</span><span class="o">=</span><span class="n">HEOS_max_iter</span><span class="p">,</span>
                    <span class="n">print_convergence</span><span class="o">=</span><span class="n">HEOS_print_convergence</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Update guess for the next integration step</span>
                <span class="c1"># Use only previous metastable calculation as initial guess (never equilibrium calculation)</span>
                <span class="c1"># Some ODE solvers do corrective steps at return to higher pressures after doing equilibrium calculations</span>
                <span class="c1"># The custom HEOS solver may fail if it uses the equilibrium state as initial guess because the density changes significantly</span>
                <span class="n">rhoT_guess_metastable</span> <span class="o">=</span> <span class="p">[</span><span class="n">state_meta</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">state_meta</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Take the equilibrium state outside the blending region</span>
                <span class="n">state_meta</span> <span class="o">=</span> <span class="n">state_eq</span>

            <span class="c1"># Compute blended state</span>
            <span class="n">state_blend</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">blend_properties</span><span class="p">(</span>
                <span class="n">phase_change</span><span class="o">=</span><span class="n">phase_change_type</span><span class="p">,</span>
                <span class="n">props_equilibrium</span><span class="o">=</span><span class="n">state_eq</span><span class="p">,</span>
                <span class="n">props_metastable</span><span class="o">=</span><span class="n">state_meta</span><span class="p">,</span>
                <span class="n">blending_variable</span><span class="o">=</span><span class="s2">&quot;Q&quot;</span><span class="p">,</span>
                <span class="n">blending_onset</span><span class="o">=</span><span class="n">blending_onset</span><span class="p">,</span>
                <span class="n">blending_width</span><span class="o">=</span><span class="n">blending_width</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Compute right-hand-side of the ODE</span>
            <span class="n">dhdp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">efficiency</span> <span class="o">/</span> <span class="n">state_blend</span><span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">dhdp</span><span class="p">,</span> <span class="n">state_blend</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid calculation_type=&#39;</span><span class="si">{</span><span class="n">calculation_type</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Valid options are: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">CALCULATION_TYPES</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="c1"># Solve polytropic expansion differential equation</span>
    <span class="n">ode_sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span>
        <span class="n">fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="n">odefun</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">h</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># Get only first output</span>
        <span class="n">t_span</span><span class="o">=</span><span class="p">[</span><span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">],</span>
        <span class="n">y0</span><span class="o">=</span><span class="p">[</span><span class="n">state_in</span><span class="o">.</span><span class="n">h</span><span class="p">],</span>
        <span class="n">method</span><span class="o">=</span><span class="n">ODE_solver</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">ODE_tolerance</span><span class="p">,</span>
        <span class="n">atol</span><span class="o">=</span><span class="n">ODE_tolerance</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ode_sol</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">ode_sol</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>

    <span class="c1"># Postprocess solution</span>
    <span class="c1"># Start postprocessing from inlet state, otherwise initial guess will be too far away</span>
    <span class="n">rhoT_guess_metastable</span> <span class="o">=</span> <span class="p">[</span><span class="n">state_in</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">state_in</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">postprocess_ode</span><span class="p">(</span><span class="n">ode_sol</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">ode_sol</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">odefun</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">ode_sol</span></div>



<div class="viewcode-block" id="barotropic_model_two_component">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.barotropic_model_two_component">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">barotropic_model_two_component</span><span class="p">(</span>
    <span class="n">fluid_name_1</span><span class="p">,</span>
    <span class="n">fluid_name_2</span><span class="p">,</span>
    <span class="n">mixture_ratio</span><span class="p">,</span>
    <span class="n">T_in</span><span class="p">,</span>
    <span class="n">p_in</span><span class="p">,</span>
    <span class="n">p_out</span><span class="p">,</span>
    <span class="n">efficiency</span><span class="p">,</span>
    <span class="n">backend</span><span class="o">=</span><span class="s2">&quot;HEOS&quot;</span><span class="p">,</span>
    <span class="n">process_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ODE_solver</span><span class="o">=</span><span class="s2">&quot;lsoda&quot;</span><span class="p">,</span>
    <span class="n">ODE_tolerance</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates a polytropic process for a mixture of two different fluids.</span>

<span class="sd">    TODO: add model equations and explanation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fluid_name_1 : str</span>
<span class="sd">        The name of the first component of the mixture.</span>
<span class="sd">    fluid_name_2 : str</span>
<span class="sd">        The name of the second component of the mixture.</span>
<span class="sd">    mixture_ratio : float</span>
<span class="sd">        Mass ratio of the first to the second fluid in the mixture.</span>
<span class="sd">    T_in : float</span>
<span class="sd">        Inlet temperature of the mixture in Kelvin.</span>
<span class="sd">    p_in : float</span>
<span class="sd">        Inlet pressure of the mixture in Pascals.</span>
<span class="sd">    p_out : float</span>
<span class="sd">        Outlet pressure of the mixture in Pascals.</span>
<span class="sd">    efficiency : float</span>
<span class="sd">        The efficiency of the polytropic process, (between zero and one).</span>
<span class="sd">    ODE_solver : str, optional</span>
<span class="sd">        The solver to use for the ODE integration. Valid options:</span>

<span class="sd">        .. list-table::</span>
<span class="sd">            :widths: 20 50</span>
<span class="sd">            :header-rows: 1</span>

<span class="sd">            * - Solver name</span>
<span class="sd">              - Description</span>
<span class="sd">            * - ``RK23``</span>
<span class="sd">              - Explicit Runge-Kutta method of order 3(2)</span>
<span class="sd">            * - ``RK45``</span>
<span class="sd">              - Explicit Runge-Kutta method of order 5(4)</span>
<span class="sd">            * - ``DOP853``</span>
<span class="sd">              - Explicit Runge-Kutta method of order 8</span>
<span class="sd">            * - ``Radau``</span>
<span class="sd">              - Implicit Runge-Kutta method of the Radau IIA family of order 5</span>
<span class="sd">            * - ``BDF``</span>
<span class="sd">              - Implicit multi-step variable-order (1 to 5) method based on a backward differentiation formula for the derivative approximation</span>
<span class="sd">            * - ``LSODA``</span>
<span class="sd">              - Adams/BDF method with automatic stiffness detection and switching</span>

<span class="sd">        See `Scipy solver_ivp() &lt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html&gt;`_  for more info.</span>
<span class="sd">        Recommended solvers: ``BDF``, ``LSODA``, or ``Radau`` for stiff problems or ``RK45`` for non-stiff problems with smooth blending.</span>

<span class="sd">    ODE_tolerance : float, optional</span>
<span class="sd">        The relative and absolute tolerance for the ODE solver.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    states : dictionary of arrays</span>
<span class="sd">        A dictionary of Numpy arrays representing the properties of the fluid at each evaluation point.</span>
<span class="sd">    solution : scipy.integrate.OdeResult</span>
<span class="sd">        The result of the ODE integration containing information about the solver process.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check if the provided ODE_solver is valid</span>
    <span class="n">valid_solvers_ode</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ODE_METHODS</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">ODE_solver</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_solvers_ode</span><span class="p">:</span>
        <span class="n">error_message</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid ODE solver &#39;</span><span class="si">{</span><span class="n">ODE_solver</span><span class="si">}</span><span class="s2">&#39; provided. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Valid solver are: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">valid_solvers_ode</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_message</span><span class="p">)</span>

    <span class="c1"># Pre-process efficiency value</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">efficiency</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Efficiency must be between 0 and 1. Provided: </span><span class="si">{</span><span class="n">efficiency</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">process_type</span> <span class="o">==</span> <span class="s2">&quot;compression&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">efficiency</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Efficiency cannot be zero for compression (division by zero).&quot;</span>
            <span class="p">)</span>
        <span class="n">efficiency</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">efficiency</span>
    <span class="k">elif</span> <span class="n">process_type</span> <span class="o">!=</span> <span class="s2">&quot;expansion&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid process_type=&#39;</span><span class="si">{</span><span class="n">process_type</span><span class="si">}</span><span class="s2">&#39;. Must be &#39;expansion&#39; or &#39;compression&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Initialize fluid and compute inlet state</span>
    <span class="n">fluid_1</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">Fluid</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">fluid_name_1</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">fluid_2</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">Fluid</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">fluid_name_2</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Compute the inlet enthalpy of the mixture (ODE initial value)</span>
    <span class="n">state_in</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">get_mixture_state</span><span class="p">(</span><span class="n">fluid_1</span><span class="p">,</span> <span class="n">fluid_2</span><span class="p">,</span> <span class="n">p_in</span><span class="p">,</span> <span class="n">T_in</span><span class="p">,</span> <span class="n">mixture_ratio</span><span class="p">)</span>
    <span class="n">h_in</span> <span class="o">=</span> <span class="n">state_in</span><span class="o">.</span><span class="n">enthalpy</span>

    <span class="c1"># Define the ODE system</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">odefun</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>

        <span class="c1"># Compute mixture thermodynamic properties</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">t</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">get_mixture_state</span><span class="p">(</span><span class="n">fluid_1</span><span class="p">,</span> <span class="n">fluid_2</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">mixture_ratio</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

        <span class="c1"># Compute derived properties</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;velocity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">h_in</span> <span class="o">-</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;enthalpy&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">))</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;Mach&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;velocity&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;speed_of_sound&quot;</span><span class="p">]</span>

        <span class="c1"># Compute right-hand-side of the ODE</span>
        <span class="n">dhdp</span> <span class="o">=</span> <span class="n">efficiency</span> <span class="o">/</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">]</span>
        <span class="n">dTdp</span> <span class="o">=</span> <span class="n">dhdp</span> <span class="o">/</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;isobaric_heat_capacity&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;joule_thomson&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">dhdp</span><span class="p">,</span> <span class="n">dTdp</span><span class="p">],</span> <span class="n">state</span>

    <span class="c1"># Solve polytropic expansion differential equation</span>
    <span class="n">ode_sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span>
        <span class="n">fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="n">odefun</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">h</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># Get only first output</span>
        <span class="n">t_span</span><span class="o">=</span><span class="p">[</span><span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">],</span>
        <span class="n">y0</span><span class="o">=</span><span class="p">[</span><span class="n">h_in</span><span class="p">,</span> <span class="n">T_in</span><span class="p">],</span>
        <span class="n">method</span><span class="o">=</span><span class="n">ODE_solver</span><span class="p">,</span>
        <span class="n">rtol</span><span class="o">=</span><span class="n">ODE_tolerance</span><span class="p">,</span>
        <span class="n">atol</span><span class="o">=</span><span class="n">ODE_tolerance</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ode_sol</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">ode_sol</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>

    <span class="c1"># Postprocess solution</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">postprocess_ode</span><span class="p">(</span><span class="n">ode_sol</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">ode_sol</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">odefun</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">ode_sol</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_data_available</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to ensure that poly_handles and poly_breakpoints are available before executing a method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Polynomials or breakpoints are not initialized. Please fit the model first.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<div class="viewcode-block" id="PolynomialFitter">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.PolynomialFitter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PolynomialFitter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # TODO update docstring</span>
<span class="sd">    Fits polynomials to the thermodynamic properties of a fluid across various states.</span>

<span class="sd">    polynomial_degree : int</span>
<span class="sd">        Degree of the polynomials to fit.</span>

<span class="sd">        .. note::</span>

<span class="sd">            When `calculation_type` is ``blending`` the degree of the polynomial in the blending region is set to 4 to achieve sufficient accuracy while preventing numerical round-off errors associated with single-precision arithmetic in CFD solvers.</span>

<span class="sd">    polynomial_format : str, optional</span>
<span class="sd">        Type of polynomial representation (``horner`` or ``standard``). Default is &#39;horner&#39;.</span>

<span class="sd">    polynomial_variables : list of str</span>
<span class="sd">        A list of variable names to fit polynomials to, such as &#39;density&#39;, &#39;viscosity&#39;, &#39;speed_of_sound&#39;, &#39;void_fraction&#39;, &#39;vapor_quality&#39;.</span>

<span class="sd">    output_dir : str</span>
<span class="sd">        The directory where output will be saved.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">,</span>
        <span class="n">state_in</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">,</span>
        <span class="n">degree</span><span class="p">,</span>
        <span class="n">calculation_type</span><span class="p">,</span>
        <span class="n">model_type</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;barotropic_model&quot;</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="c1"># Rename arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_in</span> <span class="o">=</span> <span class="n">state_in</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span> <span class="o">=</span> <span class="n">degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">=</span> <span class="n">model_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculation_type</span> <span class="o">=</span> <span class="n">calculation_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir_default</span> <span class="o">=</span> <span class="n">output_dir</span>

        <span class="c1"># Initialize variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;pressure&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;pressure&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_in_scaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_out_scaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_out</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span>

        <span class="c1"># Preprocess vapor quality and void fraction to avoid NaNs</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;vapor_quality&quot;</span><span class="p">,</span> <span class="s2">&quot;void_fraction&quot;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># Find the first finite (non-NaN) value</span>
                <span class="n">valid_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">valid_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">first_value</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_value</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All values in &#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&#39; are NaN — cannot proceed.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="PolynomialFitter.fit_polynomials">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.PolynomialFitter.fit_polynomials">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_polynomials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits polynomials to the data obtained from the ODE solution based on the specified calculation type.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculation_type</span> <span class="o">==</span> <span class="s2">&quot;equilibrium&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fit_equilibrium</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculation_type</span> <span class="o">==</span> <span class="s2">&quot;blending&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fit_blending</span><span class="p">()</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculation_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;metastable&quot;</span><span class="p">]</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;two-component&quot;</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fit_single_segment</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid calculation_type=&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">calculation_type</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Valid options are: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">CALCULATION_TYPES</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_fit_single_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fits a single polynomial segment when &#39;calculation_type&#39; is not specified&#39;&quot;&quot;&quot;</span>
        <span class="c1"># Scale pressure by inlet pressure to improve polynomial conditioning</span>
        <span class="n">p_scaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;pressure&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span>

        <span class="c1"># Determine the polynomial limits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">p_in_scaled</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_out_scaled</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span> <span class="o">=</span> <span class="mi">6</span>

        <span class="c1"># Fit polynomials to data</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var</span><span class="p">])</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">p_scaled</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly</span><span class="p">]</span>

    <span class="c1"># def _fit_equilibrium(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Fits polynomials for calculation_type=&quot;equilibrium&quot;.</span>

    <span class="c1">#     This method scales pressure, identifies the phase transition, and fits polynomials for the specified variables based on single-phase and two-phase regions.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     # Scale pressure by inlet pressure to improve polynomial conditioning</span>
    <span class="c1">#     p_scaled = self.states[&quot;pressure&quot;] / self.p_in</span>

    <span class="c1">#     # Determine points within the two-phase region</span>
    <span class="c1">#     # eps = 1e-9</span>
    <span class="c1">#     # mask_1phase = np.abs(self.states[&quot;supersaturation_degree&quot;]) &gt; eps</span>
    <span class="c1">#     # mask_2phase = np.abs(self.states[&quot;supersaturation_degree&quot;]) &lt;= eps</span>
    <span class="c1">#     mask_1phase = ~self.states[&quot;is_two_phase&quot;]</span>
    <span class="c1">#     mask_2phase = self.states[&quot;is_two_phase&quot;]</span>

    <span class="c1">#     # Determine breakpoints for polynomial segments</span>
    <span class="c1">#     if mask_1phase.any() and mask_2phase.any():</span>
    <span class="c1">#         # Transition from single- to two-phase</span>
    <span class="c1">#         p_transition = p_scaled[np.where(mask_2phase)[0][0]]</span>
    <span class="c1">#         self.poly_breakpoints = [self.p_in_scaled, p_transition, self.p_out_scaled]</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         # Only one phase present — no transition</span>
    <span class="c1">#         self.poly_breakpoints = [self.p_in_scaled, self.p_out_scaled]</span>

    <span class="c1">#     # Determine number of segments based on breakpoints</span>
    <span class="c1">#     n_segments = len(self.poly_breakpoints) - 1</span>

    <span class="c1">#     # Parse polynomial degrees</span>
    <span class="c1">#     if isinstance(self.poly_degree, (int, float)):</span>
    <span class="c1">#         degrees = [int(self.poly_degree)] * n_segments</span>
    <span class="c1">#     elif isinstance(self.poly_degree, list) and len(self.poly_degree) == n_segments:</span>
    <span class="c1">#         degrees = [int(d) for d in self.poly_degree]</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         raise ValueError(f&quot;Invalid poly_degree: expected scalar or list of length {n_segments}, but got: {self.poly_degree}.&quot;)</span>

    <span class="c1">#     # Fit polynomials to data</span>
    <span class="c1">#     for var in self.variables:</span>

    <span class="c1">#         self.poly_handles[var] = []</span>
    <span class="c1">#         for i in range(len(self.poly_breakpoints) - 1):</span>
    <span class="c1">#             p_start = self.poly_breakpoints[i]</span>
    <span class="c1">#             p_end = self.poly_breakpoints[i + 1]</span>

    <span class="c1">#             # Mask for points within this segment</span>
    <span class="c1">#             mask_segment = (p_scaled &lt;= p_start) &amp; (p_scaled &gt; p_end)</span>
    <span class="c1">#             if not np.any(mask_segment):</span>
    <span class="c1">#                 # No data in this segment; skip</span>
    <span class="c1">#                 self.poly_handles[var].append(None)</span>
    <span class="c1">#                 continue</span>

    <span class="c1">#             p_seg = p_scaled[mask_segment]</span>
    <span class="c1">#             y_seg = np.array(self.states[var])[mask_segment]</span>
    <span class="c1">#             poly = Polynomial.fit(p_seg, y_seg, deg=degrees[i]).convert()</span>
    <span class="c1">#             self.poly_handles[var].append(poly)</span>
              
    <span class="k">def</span><span class="w"> </span><span class="nf">_fit_equilibrium</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits polynomials for calculation_type=&quot;equilibrium&quot;.</span>

<span class="sd">        This method scales pressure, identifies the phase transition, and fits polynomials for the specified variables based on single-phase and two-phase regions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Scale pressure by inlet pressure to improve polynomial conditioning</span>
        <span class="n">p_scaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;pressure&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span>

        <span class="c1"># Determine points within the two-phase region</span>
        <span class="c1"># eps = 1e-9</span>
        <span class="c1"># mask_1phase = np.abs(self.states[&quot;supersaturation_degree&quot;]) &gt; eps</span>
        <span class="c1"># mask_2phase = np.abs(self.states[&quot;supersaturation_degree&quot;]) &lt;= eps</span>
        <span class="n">mask_2phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;is_two_phase&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">mask_1phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;is_two_phase&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Determine breakpoints for polynomial segments (covers wet-to-dry expansion!)</span>
        <span class="n">idx_2phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_2phase</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">idx_2phase</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i_start</span> <span class="o">=</span> <span class="n">idx_2phase</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i_end</span> <span class="o">=</span> <span class="n">idx_2phase</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Offset by 1 point</span>

            <span class="c1"># Always include start and end of domain</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">p_in_scaled</span><span class="p">]</span>

            <span class="c1"># Enter two-phase region</span>
            <span class="k">if</span> <span class="n">i_start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_scaled</span><span class="p">[</span><span class="n">i_start</span><span class="p">])</span>

            <span class="c1"># Exit two-phase region</span>
            <span class="k">if</span> <span class="n">i_end</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_scaled</span><span class="p">):</span>
                <span class="n">bp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_scaled</span><span class="p">[</span><span class="n">i_end</span><span class="p">])</span>

            <span class="c1"># Add outlet breakpoint</span>
            <span class="n">bp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_out_scaled</span><span class="p">)</span>

            <span class="c1"># Remove duplicates while preserving order</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">bp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only single phase</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">p_in_scaled</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_out_scaled</span><span class="p">]</span>

        <span class="c1"># Determine number of segments based on breakpoints</span>
        <span class="n">n_segments</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Parse polynomial degrees</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n_segments</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_segments</span><span class="p">:</span>
            <span class="n">degrees</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid poly_degree: expected scalar or list of length </span><span class="si">{</span><span class="n">n_segments</span><span class="si">}</span><span class="s2">, but got: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># Fit polynomials to data</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">p_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">p_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Mask for points within this segment</span>
                <span class="n">mask_segment</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_scaled</span> <span class="o">&lt;=</span> <span class="n">p_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_scaled</span> <span class="o">&gt;</span> <span class="n">p_end</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask_segment</span><span class="p">):</span>
                    <span class="c1"># No data in this segment; skip</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">p_seg</span> <span class="o">=</span> <span class="n">p_scaled</span><span class="p">[</span><span class="n">mask_segment</span><span class="p">]</span>
                <span class="n">y_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var</span><span class="p">])[</span><span class="n">mask_segment</span><span class="p">]</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">p_seg</span><span class="p">,</span> <span class="n">y_seg</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">degrees</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
                

    <span class="k">def</span><span class="w"> </span><span class="nf">_fit_blending</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits polynomials for calculation_type=&quot;blending&quot;.</span>

<span class="sd">        This method identifies different regions based on the blending parameter &quot;x&quot; and fits polynomials to ensure continuity across regions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the scaled pressure values</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;pressure&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span>

        <span class="c1"># Define masks for different regions based on states[&quot;x&quot;]</span>
        <span class="c1"># limit = 0.96</span>
        <span class="c1"># limit = 0.8</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">mask_region_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">limit</span>
        <span class="n">mask_region_2</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)</span>
        <span class="n">mask_region_3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span>

        <span class="c1"># Determine breakpoints in terms of scaled pressure</span>
        <span class="n">p_region_2_start</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">mask_region_2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p_region_2_end</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">mask_region_2</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_in_scaled</span><span class="p">,</span>
            <span class="n">p_region_2_start</span><span class="p">,</span>
            <span class="n">p_region_2_end</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_out_scaled</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="c1"># Fit polynomials to data</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># TODO Clean</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">degree_1</span><span class="p">,</span> <span class="n">degree_2</span><span class="p">,</span> <span class="n">degree_3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">degree_1</span> <span class="o">=</span> <span class="n">degree_2</span> <span class="o">=</span> <span class="n">degree_3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The variable poly_degree must be a scalar or a list with 3 items, but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_degree</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Fit polynomial for Region 1 (x &gt; 1)</span>
            <span class="n">y_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var</span><span class="p">])[</span><span class="n">mask_region_1</span><span class="p">]</span>
            <span class="n">p_1</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">mask_region_1</span><span class="p">]</span>
            <span class="n">degree_1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">degree_1</span><span class="p">)</span>
            <span class="n">poly_1</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">p_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">degree_1</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_1</span><span class="p">)</span>

            <span class="c1"># Fit polynomial for Region 2 (0 &lt;= x &lt;= 1)</span>
            <span class="n">y_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var</span><span class="p">])[</span><span class="n">mask_region_2</span><span class="p">]</span>
            <span class="n">p_2</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">mask_region_2</span><span class="p">]</span>
            <span class="n">degree_2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">degree_2</span><span class="p">)</span>
            <span class="n">poly_2</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">p_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">degree_2</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

            <span class="c1"># Ensure continuity by adjusting the first coefficient</span>
            <span class="n">y_1_end</span> <span class="o">=</span> <span class="n">poly_1</span><span class="p">(</span><span class="n">p_region_2_start</span><span class="p">)</span>
            <span class="n">y_2_start</span> <span class="o">=</span> <span class="n">poly_2</span><span class="p">(</span><span class="n">p_region_2_start</span><span class="p">)</span>
            <span class="n">coeffs_2</span> <span class="o">=</span> <span class="n">poly_2</span><span class="o">.</span><span class="n">coef</span>
            <span class="n">coeffs_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">y_2_start</span> <span class="o">-</span> <span class="n">y_1_end</span>
            <span class="n">poly_2</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="p">(</span><span class="n">coeffs_2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_2</span><span class="p">)</span>

            <span class="c1"># Fit polynomial for Region 3 (x &lt; 0)</span>
            <span class="n">y_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var</span><span class="p">])[</span><span class="n">mask_region_3</span><span class="p">]</span>
            <span class="n">p_3</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">mask_region_3</span><span class="p">]</span>
            <span class="n">degree_3</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">degree_3</span><span class="p">)</span>
            <span class="n">poly_3</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">p_3</span><span class="p">,</span> <span class="n">y_3</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">degree_3</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

            <span class="c1"># Ensure continuity by adjusting the first coefficient</span>
            <span class="n">y_2_end</span> <span class="o">=</span> <span class="n">poly_2</span><span class="p">(</span><span class="n">p_region_2_end</span><span class="p">)</span>
            <span class="n">y_3_start</span> <span class="o">=</span> <span class="n">poly_3</span><span class="p">(</span><span class="n">p_region_2_end</span><span class="p">)</span>
            <span class="n">coeffs_3</span> <span class="o">=</span> <span class="n">poly_3</span><span class="o">.</span><span class="n">coef</span>
            <span class="n">coeffs_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">y_3_start</span> <span class="o">-</span> <span class="n">y_2_end</span>
            <span class="n">poly_3</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="p">(</span><span class="n">coeffs_3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_3</span><span class="p">)</span>

<div class="viewcode-block" id="PolynomialFitter.evaluate_polynomial">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.PolynomialFitter.evaluate_polynomial">[docs]</a>
    <span class="nd">@_ensure_data_available</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">print_warning</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the polynomials for a given variable at a specified pressure values.</span>

<span class="sd">        The function evaluates the polynomial values at a given physical pressure `p`</span>
<span class="sd">        for a variable (e.g., density). It automatically determines the correct branch</span>
<span class="sd">        of the piecewise polynomial based on the breakpoints, and applies safeguards for </span>
<span class="sd">        pressures outside the limits to ensure sensible values and continuity.</span>

<span class="sd">        The evaluation follows a piecewise definition depending on the range of :math:`\hat{p}=p/p_{\text{in}}`:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \phi(\hat{p}) = </span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            a_1 \, e^\left(\frac{\hat{p} - \hat{p}_{\text{out}}}{a_2}\right) &amp; \text{ for } &amp; \hat{p} &lt; \hat{p}_{\text{out}} \\</span>
<span class="sd">            \sum_{i=0}^{d} b_{i,1} \, \hat{p}^i &amp; \text{ for }  &amp; \hat{p}_{\text{ out}} \leq \hat{p} \leq \hat{p}_{1} \\</span>
<span class="sd">            &amp; \;\; \vdots  &amp; \\</span>
<span class="sd">            \sum_{i=0}^{d} b_{i,n} \, \hat{p}^i &amp; \text{ for }  &amp; \hat{p}_{n} \leq \hat{p} \leq \hat{p}_{\text{in}} \\</span>
<span class="sd">            c_1 + c_2 \left(\hat{p} - \hat{p}_{\text{in}}\right) &amp; \text{ for }  &amp; \hat{p} &gt; \hat{p}_{\text{in}}</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        where:</span>

<span class="sd">        - :math:`\phi(p)` is the variable being fitted (e.g., density, viscosity).</span>
<span class="sd">        - :math:`a_1` and :math:`a_2` are constants of the exponential function used to extrapolate the properties below the outlet pressure. The numerical values are determined to match the polynomial value and its first derivative at the endpoint :math:`\hat{p}=\hat{p}_{\text{out}}`.</span>
<span class="sd">        - :math:`b_{i,j}` is the :math:`i`-th polynomial coefficient of the :math:`j`-th polynomial segment, where :math:`d` is the degree of the polynomials, :math:`n` is the number of breakpoints, and :math:`n+1` is the number of polynomial segments. Additionally, :math:`[\hat{p}_{\text{out}},\, \hat{p}_{1},\,\ldots,\, \hat{p}_{n},\,\hat{p}_{\text{in}}]` are normalized pressures at the breakpoints.</span>
<span class="sd">        - :math:`c_1` and :math:`c_2` are constants of the linear function used to extrapolate the properties above the inlet pressure. The numerical values are determined to match the polynomial value and its first derivative at the endpoint :math:`\hat{p}=\hat{p}_{\text{in}}`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The safeguards for pressures outside the specified limits help to avoid numerical issues by applying </span>
<span class="sd">            exponential decay for pressures below :math:`p_{\text{out}}` and linear extrapolation for pressures above </span>
<span class="sd">            :math:`p_{\text{in}}`. These measures prevent properties from becoming negative or excessively large, which </span>
<span class="sd">            can occur with very high or low (even negative) pressures during internal iterations of CFD solvers.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p : array-like</span>
<span class="sd">            The physical pressure values at which to evaluate the polynomials. </span>
<span class="sd">            Given in Pascals (Pa).</span>
<span class="sd">        variable : str</span>
<span class="sd">            The variable for which to evaluate the polynomial, such as &#39;density&#39;, &#39;viscosity&#39;, </span>
<span class="sd">            &#39;speed_of_sound&#39;, or &#39;void_fraction&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        var_values : ndarray</span>
<span class="sd">            The evaluated values of the variable at the given physical pressures.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Note:</span>
        <span class="c1"># The argument to the polynomials in self.poly_handles() should be the normalized pressures (not physical pressures)</span>
        <span class="c1"># The values in self.poly_breakpoints are normalized pressures (not physical pressures)</span>

        <span class="c1"># Convert input to array and scale</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">p_scaled</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span>

        <span class="c1"># Reverse order of breakpoints if pressure is ascending (compression vs expansion)</span>
        <span class="n">bps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span><span class="p">)</span>
        <span class="n">bps</span> <span class="o">=</span> <span class="n">bps</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_out</span> <span class="k">else</span> <span class="n">bps</span>

        <span class="c1"># Loop over polynomial segments</span>
        <span class="n">var_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="p">[])):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_scaled</span> <span class="o">&lt;=</span> <span class="n">bps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">p_scaled</span> <span class="o">&gt;</span> <span class="n">bps</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="n">var_values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly</span><span class="p">(</span><span class="n">p_scaled</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No polynomials found for variable &#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># Safeguard for pressures lower than the lowest breakpoint (exponential decay)</span>
        <span class="n">p_min_scaled</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_in_scaled</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_out_scaled</span><span class="p">)</span>
        <span class="n">mask_lower</span> <span class="o">=</span> <span class="n">p_scaled</span> <span class="o">&lt;=</span> <span class="n">p_min_scaled</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask_lower</span><span class="p">):</span>
            <span class="n">poly_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="p">[</span><span class="n">variable</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">poly_last</span><span class="p">(</span><span class="n">p_min_scaled</span><span class="p">)</span>
            <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="mf">1e-9</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">poly_last</span><span class="o">.</span><span class="n">deriv</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">)(</span><span class="n">p_min_scaled</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">exp_values</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">p_scaled</span><span class="p">[</span><span class="n">mask_lower</span><span class="p">]</span> <span class="o">-</span> <span class="n">p_min_scaled</span><span class="p">)</span> <span class="o">/</span> <span class="n">a2</span><span class="p">)</span>
            <span class="n">var_values</span><span class="p">[</span><span class="n">mask_lower</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp_values</span>

            <span class="k">if</span> <span class="n">a2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">print_warning</span> <span class="ow">and</span> <span class="n">variable</span> <span class="o">==</span> <span class="s2">&quot;density&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid extrapolation to negative pressures: a2=</span><span class="si">{</span><span class="n">a2</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2"> produces exponential growth instead of decay.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Adjust the pressure limits or the degree of the fitting polynomials.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Safeguard for pressures higher than the highest breakpoint (linear extrapolation)</span>
        <span class="n">p_max_scaled</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_in_scaled</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_out_scaled</span><span class="p">)</span>
        <span class="n">mask_upper</span> <span class="o">=</span> <span class="n">p_scaled</span> <span class="o">&gt;</span> <span class="n">p_max_scaled</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask_upper</span><span class="p">):</span>
            <span class="n">poly_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_handles</span><span class="p">[</span><span class="n">variable</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">poly_first</span><span class="p">(</span><span class="n">p_max_scaled</span><span class="p">)</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">poly_first</span><span class="o">.</span><span class="n">deriv</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">)(</span><span class="n">p_max_scaled</span><span class="p">)</span>
            <span class="n">extrap</span> <span class="o">=</span> <span class="n">b1</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">*</span> <span class="p">(</span><span class="n">p_scaled</span><span class="p">[</span><span class="n">mask_upper</span><span class="p">]</span> <span class="o">-</span> <span class="n">p_max_scaled</span><span class="p">)</span>
            <span class="n">var_values</span><span class="p">[</span><span class="n">mask_upper</span><span class="p">]</span> <span class="o">=</span> <span class="n">extrap</span>

        <span class="k">return</span> <span class="n">var_values</span></div>


<div class="viewcode-block" id="PolynomialFitter.plot_polynomial">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.PolynomialFitter.plot_polynomial">[docs]</a>
    <span class="nd">@_ensure_data_available</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_polynomial</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">p_eval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">showfig</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the polynomials for the specified variable. If the pressure values for plotting are not provided, a suitable range is generated internally.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var : str</span>
<span class="sd">            The variable for which to plot the polynomial.</span>

<span class="sd">        p_eval : array-like, optional</span>
<span class="sd">            The pressure values at which to plot the polynomial. If not provided, automatic values are generated.</span>

<span class="sd">        showfig : bool, optional</span>
<span class="sd">            If True, displays the plot.</span>

<span class="sd">        savefig : bool, optional</span>
<span class="sd">            If True, saves the plot to a file.</span>

<span class="sd">        output_dir : str, optional</span>
<span class="sd">            The directory where the plot will be saved if `savefig` is True. If not specified, uses the default output directory of the class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure.Figure</span>
<span class="sd">            The figure object containing the plotted data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If output_dir is not given, set it to the default directory</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir_default</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

        <span class="c1"># Create a figure and axis</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

        <span class="c1"># Set axis labels</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Pressure (Pa)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">props</span><span class="o">.</span><span class="n">LABEL_MAPPING</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">var</span><span class="p">))</span>

        <span class="c1"># Plot specified values or segments between breakpoints</span>
        <span class="k">if</span> <span class="n">p_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># Plot polynomial at specified pressures</span>
            <span class="n">prop_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_polynomial</span><span class="p">(</span><span class="n">p_eval</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p_eval</span><span class="p">,</span> <span class="n">prop_eval</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">COLORS_MATLAB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Reverse order of breakpoints if pressure is ascending (compression vs expansion)</span>
            <span class="n">bps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span><span class="p">)</span>
            <span class="n">bps</span> <span class="o">=</span> <span class="n">bps</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_out</span> <span class="k">else</span> <span class="n">bps</span>

            <span class="c1"># Concatenate to form the complete list of breakpoints</span>
            <span class="n">breakpoints</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.8</span> <span class="o">*</span> <span class="n">bps</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">bps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># Iterate over the breakpoints and plot the segments</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>

                <span class="c1"># Generate segments between breakpoints</span>
                <span class="n">bp1</span> <span class="o">=</span> <span class="n">breakpoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">bp2</span> <span class="o">=</span> <span class="n">breakpoints</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">p_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span>

                <span class="c1"># Evaluate the polynomial over the segment</span>
                <span class="n">prop_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_polynomial</span><span class="p">(</span><span class="n">p_segment</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p_segment</span><span class="p">,</span> <span class="n">prop_eval</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">COLORS_MATLAB</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># Plot points just before breakpoints to check continuity</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-12</span>
                <span class="n">x_minus</span> <span class="o">=</span> <span class="p">(</span><span class="n">bp2</span> <span class="o">-</span> <span class="n">eps</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span>
                <span class="n">y_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_polynomial</span><span class="p">(</span><span class="n">x_minus</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_minus</span><span class="p">,</span> <span class="n">y_minus</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">COLORS_MATLAB</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># Plot points just after breakpoints to check continuity</span>
                <span class="n">x_plus</span> <span class="o">=</span> <span class="p">(</span><span class="n">bp2</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span>
                <span class="n">y_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_polynomial</span><span class="p">(</span><span class="n">x_plus</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_plus</span><span class="p">,</span> <span class="n">y_plus</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">COLORS_MATLAB</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">savefig</span><span class="p">:</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;barotropic_model_</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">graphics</span><span class="o">.</span><span class="n">savefig_in_formats</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">showfig</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="PolynomialFitter.plot_polynomial_and_error">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.PolynomialFitter.plot_polynomial_and_error">[docs]</a>
    <span class="nd">@_ensure_data_available</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_polynomial_and_error</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">showfig</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the barotropic polynomials and original data points from the ODE solution to illustrate</span>
<span class="sd">        the quality of the fit. Additionally, plots the relative error between the polynomial and the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var : str</span>
<span class="sd">            The variable to plot (e.g., &#39;density&#39;, &#39;viscosity&#39;, etc.).</span>

<span class="sd">        num_points : int, optional</span>
<span class="sd">            Number of plot points for each of the polynomial segments.</span>

<span class="sd">        showfig : bool, optional</span>
<span class="sd">            If True, displays the plot.</span>

<span class="sd">        savefig : bool, optional</span>
<span class="sd">            If True, saves the plot to a file.</span>

<span class="sd">        output_dir : str, optional</span>
<span class="sd">            The directory where the plot will be saved if `savefig` is True. If not specified, uses the default output directory of the class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure.Figure</span>
<span class="sd">            The figure object containing the plotted data and error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If output_dir is not given, set it to the default directory</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir_default</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

        <span class="c1"># Create a figure with two vertically stacked subplots</span>
        <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="c1"># ax1.set_yscale(&quot;log&quot;)</span>

        <span class="c1"># Mapping variable names to axis labels (variable name if not found)</span>
        <span class="n">x_label</span> <span class="o">=</span> <span class="s2">&quot;Pressure (Pa)&quot;</span>
        <span class="n">y_label</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">LABEL_MAPPING</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

        <span class="c1"># Generate pressure values for the state points and calculate relative error</span>
        <span class="n">p_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="s2">&quot;pressure&quot;</span><span class="p">]</span>
        <span class="n">prop_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="n">relative_error</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">100</span>
            <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate_polynomial</span><span class="p">(</span><span class="n">p_states</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span> <span class="o">-</span> <span class="n">prop_states</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">prop_states</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Plot polynomial and data segments for each breakpoint</span>
        <span class="n">extrap_lower</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># extrap_lower = 0 * self.poly_breakpoints[0]</span>
        <span class="n">extrap_upper</span> <span class="o">=</span> <span class="o">+</span><span class="mf">1.2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">breakpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">extrap_upper</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_breakpoints</span> <span class="o">+</span> <span class="p">[</span><span class="n">extrap_lower</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Define segment range between breakpoints</span>
            <span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span> <span class="o">=</span> <span class="n">breakpoints</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">breakpoints</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">p_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bp1</span><span class="p">,</span> <span class="n">bp2</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span>

            <span class="c1"># Evaluate polynomial on segment</span>
            <span class="n">prop_poly_segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_polynomial</span><span class="p">(</span><span class="n">p_segment</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">print_warning</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">p_segment</span><span class="p">,</span>
                <span class="n">prop_poly_segment</span><span class="p">,</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
                <span class="c1"># marker=&quot;+&quot;,</span>
                <span class="c1"># color=COLORS_MATLAB[1],</span>
            <span class="p">)</span>

        <span class="c1"># Plot original data points</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">p_states</span><span class="p">,</span>
            <span class="n">prop_states</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Original values&quot;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">COLORS_MATLAB</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_in</span><span class="p">[</span><span class="s2">&quot;pressure&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_in</span><span class="p">[</span><span class="n">var</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.25</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span>
            <span class="n">markerfacecolor</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">y_label</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower right&quot;</span><span class="p">)</span>

        <span class="c1"># Adjust x-limits</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">extrap_upper</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_in</span><span class="p">)</span>

        <span class="c1"># Automatically adjust y-limits if data is nearly constant</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">prop_states</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">prop_states</span><span class="p">)</span>
        <span class="n">yrange</span> <span class="o">=</span> <span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span>
        <span class="k">if</span> <span class="n">yrange</span> <span class="o">&lt;</span> <span class="mf">1e-6</span> <span class="ow">or</span> <span class="n">yrange</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">prop_states</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">:</span>
            <span class="n">ycenter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">prop_states</span><span class="p">)</span>
            <span class="n">ymargin</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ycenter</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ycenter</span> <span class="o">-</span> <span class="n">ymargin</span><span class="p">,</span> <span class="n">ycenter</span> <span class="o">+</span> <span class="n">ymargin</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ymax</span><span class="p">):</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">ymax</span><span class="p">)</span>

        <span class="c1"># Plot relative error</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">p_states</span><span class="p">,</span>
            <span class="n">relative_error</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Relative Error&quot;</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">COLORS_MATLAB</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">p_states</span><span class="p">,</span>
            <span class="n">relative_error</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">COLORS_MATLAB</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">x_label</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Relative error (%)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">savefig</span><span class="p">:</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;barotropic_model_error_</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">graphics</span><span class="o">.</span><span class="n">savefig_in_formats</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">showfig</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="PolynomialFitter.plot_phase_diagram">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.PolynomialFitter.plot_phase_diagram">[docs]</a>
    <span class="nd">@_ensure_data_available</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_phase_diagram</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fluid</span><span class="p">,</span>
        <span class="n">var_x</span><span class="p">,</span>
        <span class="n">var_y</span><span class="p">,</span>
        <span class="n">savefig</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">showfig</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_spinodal_line</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">plot_quality_isolines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">dT_crit</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the barotropic process in the phase diagram of the specified fluid.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This function is applicable to single-component systems</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fluid : Fluid</span>
<span class="sd">            Fluid object used to plot the phase diagram.</span>
<span class="sd">        var_x : str</span>
<span class="sd">            Variable for the x-axis (e.g., &quot;s&quot; for entropy).</span>
<span class="sd">        var_y : str</span>
<span class="sd">            Variable for the y-axis (e.g., &quot;T&quot; for temperature).</span>
<span class="sd">        savefig : bool, optional</span>
<span class="sd">            If True, saves the figure to the specified directory. Default is True.</span>
<span class="sd">        showfig : bool, optional</span>
<span class="sd">            If True, displays the figure after plotting. Default is True.</span>
<span class="sd">        output_dir : str, optional</span>
<span class="sd">            Directory where the plot will be saved if `savefig` is True. If not specified,</span>
<span class="sd">            uses the default output directory of the class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib.figure.Figure</span>
<span class="sd">            The figure object containing the plotted phase diagram.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If output_dir is not given, set it to the default directory</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir_default</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

        <span class="c1"># Create a figure and axis</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Barotropic process for </span><span class="si">{</span><span class="n">fluid</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>  <span class="c1"># Adjust this value to control the distance</span>
        <span class="p">)</span>

        <span class="c1"># Apply the mapping if it exists; otherwise, use the variable name</span>
        <span class="n">var_x</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">ALIAS_TO_CANONICAL</span><span class="p">[</span><span class="n">var_x</span><span class="p">]</span>
        <span class="n">var_y</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">ALIAS_TO_CANONICAL</span><span class="p">[</span><span class="n">var_y</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">props</span><span class="o">.</span><span class="n">LABEL_MAPPING</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var_x</span><span class="p">,</span> <span class="n">var_x</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">props</span><span class="o">.</span><span class="n">LABEL_MAPPING</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var_y</span><span class="p">,</span> <span class="n">var_y</span><span class="p">))</span>

        <span class="c1"># Plot phase diagram for the first subplot</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">plot_phase_diagram</span><span class="p">(</span>
            <span class="n">var_x</span><span class="p">,</span>
            <span class="n">var_y</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">plot_critical_point</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">plot_saturation_line</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">plot_spinodal_line</span><span class="o">=</span><span class="n">plot_spinodal_line</span><span class="p">,</span>
            <span class="n">plot_quality_isolines</span><span class="o">=</span><span class="n">plot_quality_isolines</span><span class="p">,</span>
            <span class="n">N</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
            <span class="n">dT_crit</span><span class="o">=</span><span class="n">dT_crit</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Plots contour of void fraction</span>
        <span class="k">if</span> <span class="n">plot_quality_isolines</span><span class="p">:</span>
            <span class="n">var_z</span> <span class="o">=</span> <span class="s2">&quot;vapor_quality&quot;</span>
            <span class="c1"># var_z = &quot;void_fraction&quot;</span>
            <span class="n">prop_dict</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">compute_quality_grid</span><span class="p">(</span>
                <span class="n">fluid</span><span class="p">,</span>
                <span class="n">num_points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                <span class="n">quality_levels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
                <span class="n">dT_crit</span><span class="o">=</span><span class="n">dT_crit</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">range_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.00</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Blues</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mi">256</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">colormap</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span>
            <span class="n">contour</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span>
                <span class="n">prop_dict</span><span class="p">[</span><span class="n">var_x</span><span class="p">],</span>
                <span class="n">prop_dict</span><span class="p">[</span><span class="n">var_y</span><span class="p">],</span>
                <span class="n">prop_dict</span><span class="p">[</span><span class="n">var_z</span><span class="p">],</span>
                <span class="n">range_z</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">colormap</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Add contour lines with black edges</span>
            <span class="n">contour_lines</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span>
                <span class="n">prop_dict</span><span class="p">[</span><span class="n">var_x</span><span class="p">],</span>
                <span class="n">prop_dict</span><span class="p">[</span><span class="n">var_y</span><span class="p">],</span>
                <span class="n">prop_dict</span><span class="p">[</span><span class="n">var_z</span><span class="p">],</span>
                <span class="n">range_z</span><span class="p">,</span>
                <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Plot the calculated states</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var_x</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var_y</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="n">graphics</span><span class="o">.</span><span class="n">COLORS_MATLAB</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.25</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var_x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var_y</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="n">graphics</span><span class="o">.</span><span class="n">COLORS_MATLAB</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.25</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">markerfacecolor</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var_x</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">var_y</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="n">graphics</span><span class="o">.</span><span class="n">COLORS_MATLAB</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.25</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">markerfacecolor</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_in</span><span class="p">[</span><span class="n">var_x</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_in</span><span class="p">[</span><span class="n">var_y</span><span class="p">],</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.25</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">markerfacecolor</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># graphics.scale_graphics_x(fig, 1/fluid.critical_point.s, mode=&quot;multiply&quot;)</span>
        <span class="c1"># ax.set_xlim([0.9, 1.3])</span>
        <span class="c1"># graphics.scale_graphics_y(fig, 1/fluid.critical_point.T, mode=&quot;multiply&quot;)</span>
        <span class="c1"># ax.set_ylim([0.85, 1.05])</span>
        <span class="k">if</span> <span class="n">savefig</span><span class="p">:</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;barotropic_process_</span><span class="si">{</span><span class="n">fluid</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">graphics</span><span class="o">.</span><span class="n">savefig_in_formats</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">showfig</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>
</div>



<div class="viewcode-block" id="ExpressionExporter">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.ExpressionExporter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExpressionExporter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exports expressions describing the barotropic model for use within CFD solvers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poly_fitter : PolynomialFitter</span>
<span class="sd">        An instance of PolynomialFitter containing the polynomial coefficients and breakpoints.</span>

<span class="sd">    poly_format : str, optional</span>
<span class="sd">        Type of polynomial representation (&#39;horner&#39; or &#39;standard&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poly_fitter</span><span class="p">,</span> <span class="n">poly_format</span><span class="o">=</span><span class="s2">&quot;horner&quot;</span><span class="p">):</span>

        <span class="c1"># Rename arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span> <span class="o">=</span> <span class="n">poly_fitter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_format</span> <span class="o">=</span> <span class="n">poly_format</span>

        <span class="c1"># Define the units of the fluid properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;density&quot;</span><span class="p">:</span> <span class="s2">&quot;kg/m^3&quot;</span><span class="p">,</span>
            <span class="s2">&quot;viscosity&quot;</span><span class="p">:</span> <span class="s2">&quot;Pa*s&quot;</span><span class="p">,</span>
            <span class="s2">&quot;speed_of_sound&quot;</span><span class="p">:</span> <span class="s2">&quot;m/s&quot;</span><span class="p">,</span>
            <span class="s2">&quot;void_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vapor_quality&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
            <span class="s2">&quot;compressibility_factor&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Define syntax specifics for different solvers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_syntax</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;fluent&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;if&quot;</span><span class="p">:</span> <span class="s2">&quot;IF&quot;</span><span class="p">,</span> <span class="s2">&quot;pressure&quot;</span><span class="p">:</span> <span class="s2">&quot;AbsolutePressure&quot;</span><span class="p">},</span>
            <span class="s2">&quot;cfx&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;if&quot;</span><span class="p">:</span> <span class="s2">&quot;if&quot;</span><span class="p">,</span> <span class="s2">&quot;pressure&quot;</span><span class="p">:</span> <span class="s2">&quot;Absolute Pressure&quot;</span><span class="p">},</span>
        <span class="p">}</span>

        <span class="c1"># Format of the numbers in the exported expressions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_format</span> <span class="o">=</span> <span class="s2">&quot;0.16e&quot;</span>

        <span class="c1"># Define default output directory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir_default</span> <span class="o">=</span> <span class="n">poly_fitter</span><span class="o">.</span><span class="n">output_dir_default</span>

<div class="viewcode-block" id="ExpressionExporter.export_expressions_fluent">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.ExpressionExporter.export_expressions_fluent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">export_expressions_fluent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exports the barotropic model polynomials as expressions for use in Fluent CFD software.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_dir : str, optional</span>
<span class="sd">            The directory where the expressions will be saved. It uses a default directory if not provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export_expressions</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;fluent&quot;</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="ExpressionExporter.export_expressions_cfx">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.ExpressionExporter.export_expressions_cfx">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">export_expressions_cfx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exports the barotropic model polynomials as expressions for use in CFX CFD software.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_dir : str, optional</span>
<span class="sd">            The directory where the expressions will be saved. It uses a default directory if not provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export_expressions</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;cfx&quot;</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_export_expressions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A generic method to generate expressions for a CFD solver, given specific keywords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        solver : str</span>
<span class="sd">            The solver for which to generate expressions (&#39;fluent&#39; or &#39;cfx&#39;).</span>
<span class="sd">        output_dir : str, optional</span>
<span class="sd">            The directory where the expressions will be saved. It uses a default directory if not provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If output_dir is not given, set it to the default directory</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir_default</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

        <span class="c1"># Define syntax based on solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syntax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_syntax</span><span class="p">[</span><span class="n">solver</span><span class="p">]</span>

        <span class="c1"># Create expressions</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">solver</span><span class="si">}</span><span class="s2">_expressions.txt&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;wt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="c1"># File header</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">solver</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2"> expressions for barotropic properties</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creation datetime: </span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Generate expressions for each property</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                    <span class="n">expressions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_expressions</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
                    <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;barotropic_</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">expressions</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing unit for variable: </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ExpressionExporter.generate_expressions">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.ExpressionExporter.generate_expressions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_expressions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">unit</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a piecewise polynomial expression with extrapolation safeguards for a given variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var : str</span>
<span class="sd">            The variable name for which to generate the expression.</span>
<span class="sd">        unit : str</span>
<span class="sd">            The unit of the variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The piecewise polynomial expression with extrapolation safeguards.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Retrieve polynomial coefficients</span>
        <span class="n">p_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span><span class="o">.</span><span class="n">p_in</span>
        <span class="n">p_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span><span class="o">.</span><span class="n">p_out</span>
        <span class="n">p_in_scaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span><span class="o">.</span><span class="n">p_in_scaled</span>
        <span class="n">p_out_scaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span><span class="o">.</span><span class="n">p_out_scaled</span>
        <span class="n">polynomials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span><span class="o">.</span><span class="n">poly_handles</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="n">breakpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">p_in</span> <span class="o">*</span> <span class="n">bp</span> <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span><span class="o">.</span><span class="n">poly_breakpoints</span><span class="p">]</span>

        <span class="c1"># Reverse the order of pressures if the process is a compression rather than an expansion</span>
        <span class="k">if</span> <span class="n">p_out</span> <span class="o">&gt;</span> <span class="n">p_in</span><span class="p">:</span>
            <span class="n">p_in_scaled</span><span class="p">,</span> <span class="n">p_out_scaled</span> <span class="o">=</span> <span class="n">p_out_scaled</span><span class="p">,</span> <span class="n">p_in_scaled</span>
            <span class="n">breakpoints</span> <span class="o">=</span> <span class="n">breakpoints</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># polynomials = polynomials[::-1]  # TODO Not sure if needed</span>

        <span class="c1"># Initialize expressions</span>
        <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polynomial_expression</span><span class="p">(</span><span class="n">polynomials</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coef</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">polynomials</span><span class="p">)):</span>
            <span class="n">new_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polynomial_expression</span><span class="p">(</span><span class="n">polynomials</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">coef</span><span class="p">)</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_expression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">new_expression</span><span class="p">,</span> <span class="n">breakpoints</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Safeguard for pressures lower than p_out (Exponential decay)</span>
        <span class="n">poly_last</span> <span class="o">=</span> <span class="n">polynomials</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">poly_last</span><span class="p">(</span><span class="n">p_out_scaled</span><span class="p">)</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="mf">1e-9</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">poly_last</span><span class="o">.</span><span class="n">deriv</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">)(</span><span class="n">p_out_scaled</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">exp_safeguard</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a1</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2"> * exp((</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">syntax</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">p_in</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2"> [Pa] - </span><span class="si">{</span><span class="n">p_out_scaled</span><span class="si">}</span><span class="s2">) / (</span><span class="si">{</span><span class="n">a2</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2">))&quot;</span>
        <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_expression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">exp_safeguard</span><span class="p">,</span> <span class="n">breakpoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Safeguard for pressures higher than p_in (Linear extrapolation)</span>
        <span class="n">poly_first</span> <span class="o">=</span> <span class="n">polynomials</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">poly_first</span><span class="p">(</span><span class="n">p_in_scaled</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">poly_first</span><span class="o">.</span><span class="n">deriv</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">)(</span><span class="n">p_in_scaled</span><span class="p">)</span>
        <span class="n">lin_extrap</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c1</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2"> + </span><span class="si">{</span><span class="n">c2</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2"> * (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">syntax</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">p_in</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2"> [Pa] - </span><span class="si">{</span><span class="n">p_in_scaled</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2">)&quot;</span>
        <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_expression</span><span class="p">(</span><span class="n">lin_extrap</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">breakpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Add fluid property unit</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">!=</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">expression</span><span class="si">}</span><span class="s2">) * 1 [</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">return</span> <span class="n">expression</span></div>


<div class="viewcode-block" id="ExpressionExporter.polynomial_expression">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.ExpressionExporter.polynomial_expression">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">polynomial_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a polynomial expression string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coefficients : array-like</span>
<span class="sd">            Coefficients of the polynomial.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The polynomial expression string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_fitter</span><span class="o">.</span><span class="n">p_in</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_format</span> <span class="o">==</span> <span class="s2">&quot;horner&quot;</span><span class="p">:</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">coefficients</span><span class="p">))</span>
            <span class="n">polynomial_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)):</span>
                <span class="n">polynomial_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2"> + (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">syntax</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">p_scale</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2"> [Pa]) *</span><span class="se">\n</span><span class="s2">(</span><span class="si">{</span><span class="n">polynomial_string</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_format</span> <span class="o">==</span> <span class="s2">&quot;standard&quot;</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)):</span>
                <span class="n">summand</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2"> * (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">syntax</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">p_scale</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2"> [Pa])^</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">summand</span> <span class="o">+=</span> <span class="s2">&quot; +&quot;</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">summand</span><span class="p">)</span>
            <span class="n">polynomial_string</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The polynomial format must be &#39;horner&#39; or &#39;standard&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">polynomial_string</span></div>


<div class="viewcode-block" id="ExpressionExporter.if_expression">
<a class="viewcode-back" href="../../source/api/barotropy.barotropic_model.html#barotropy.barotropic_model.ExpressionExporter.if_expression">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">if_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression_1</span><span class="p">,</span> <span class="n">expression_2</span><span class="p">,</span> <span class="n">transition_pressure</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates an IF expression string for piecewise functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expression_1 : str</span>
<span class="sd">            The expression for the condition being true.</span>
<span class="sd">        expression_2 : str</span>
<span class="sd">            The expression for the condition being false.</span>
<span class="sd">        transition_pressure : float</span>
<span class="sd">            The transition pressure where the expressions change.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The IF expression string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">syntax</span><span class="p">[</span><span class="s1">&#39;if&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">syntax</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> &gt;= </span><span class="si">{</span><span class="n">transition_pressure</span><span class="si">:{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_format</span><span class="si">}}</span><span class="s2"> [Pa], </span><span class="se">\n</span><span class="si">{</span><span class="n">expression_1</span><span class="si">}</span><span class="s2">, </span><span class="se">\n</span><span class="si">{</span><span class="n">expression_2</span><span class="si">}</span><span class="s2">)&quot;</span></div>
</div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Roberto Agromayor, Simone Parisi, Amit Kumar, Fredrik Haglind
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024, Sustainable Thermal Power DTU.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>